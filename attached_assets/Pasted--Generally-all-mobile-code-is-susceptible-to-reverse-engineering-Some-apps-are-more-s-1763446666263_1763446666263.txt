 


 


Generally, all mobile code is susceptible to reverse engineering. Some apps are more susceptible than others. Code written in languages / frameworks that allow for dynamic introspection at runtime (Java, .NET, Objective C, Swift) are particularly at risk for reverse engineering. Detecting susceptibility to reverse engineering is fairly straight forward. First, decrypt the app store version of the app (if binary encryption is applied). Code will be susceptible if it is fairly easy to understand the app’s controlflow path, string table, and any pseudocode/source-code generated by these tools.
Bytecode obfuscation consists of multiple complementary techniques that can help create a layered defense against reverse engineering and tampering. Some typical examples of obfuscation techniques include:
▪	Renaming to alter the name of methods and variables to make the decompiled source much harder for a human to understand.
▪	Control Flow Obfuscationcreates conditional, branching, and iterative constructs that produce valid executable logic, but yield non-deterministic semantic results when decompiled.
▪	String Encryption hides strings in the executable and only restores their original value when needed
▪	Instruction Pattern Transformation converts common instructions to other, less obvious constructs potential confusing decompliers.
▪	Dummy Code Insertion inserts code that does not affect the program’s logic, but breaks decompilers or makes reverse-engineered code harder to analyze.
▪	Unused Code and Metadata Removal prunes out debug, non-essential metadata and used code from applications to reduce the information available to an attacker.

Risk Rating	Scan Type



Version 3.0 Base Score

2.3	Attack vector: LOCAL	Attack complexity: LOW
	Privileges required: HIGH	User Interaction: NONE
	Scope: UNCHANGED	Confidentiality Impact: LOW
	Integrity Impact: NONE	Availability Impact: NONE



 
OWASP Mobile Top 10 (2024)
 
M7	Insufficient Binary Protections
 
CWE	CWE-693	https://cwe.mitre.org/data/definitions/693.html


MSTG	MSTG-RESILIENCE-9	Obfuscation is applied to programmatic defenses, which in turn
impede de-obfuscation via dynamic analysis.
 

OWASP MASVS (v2)	MASVS-RESILIANCE-3	The app implements anti-static analysis mechanisms.

PCI-DSS (v4.0)	
3.2	
Protect Account Data
		Storage of account data is kept to a minimum
	3.3	Protect Account Data
		Sensitive authentication data (SAD) is not stored after authorization
	3.4	Protect Account Data
		Access to displays of full PAN and ability to copy cardholder data are restricted
	3.5	Protect Account Data
		Primary account number (PAN) is secured wherever it is stored

GDPR	
Art-25-GDPR	
Data protection by design and by default
	Art-32-GDPR	Security of processing
Risk Assessment		

Java source code is typically compiled into Java bytecode – the instruction set of the Java virtual machine. The compiled Java bytecode can be easily reversed engineered back into source code by freely available decompilers. Bytecode Obfuscation is the process of modifying Java bytecode (executable or library) so that it is much harder to read and understand for a hacker but remains fully functional.
Application is vulnerable to reverse engineering without any obfuscation



Sample proguard-rules.pro lines which fails obfuscation when used:

-dontobfuscate

Or if no proguard or obfuscation is used then you can use number of freely available Java decompilers that can recreate source code from Java bytecode (executables or libraries).
Popular decompilers include:

▪	Bytecode Viewer - A Java 8 Jar & Android APK Reverse Engineering Suite (Decompiler, Editor, Debugger & More)
▪	CFR - Another Java decompiler
▪	JDGui - Yet another fast Java decompiler
▪	Fernflower - An analytical decompiler for Java
▪	JadX - tool to decompile APK and DEX files


To enable shrinking, obfuscation, and optimization, using proguard include the following in your project-level
build.gradle file.

android {
buildTypes {
release {
 
// Enables code shrinking, obfuscation, and optimization for only
// your project's release build type. minifyEnabled true

// Enables resource shrinking, which is performed by the
// Android Gradle plugin. shrinkResources true

 








}
}
...
}
 
// Includes the default ProGuard rules files that are packaged with
// the Android Gradle plugin. To learn more, go to the section about
// R8 configuration files. proguardFiles getDefaultProguardFile(
'proguard-android-optimize.txt'), 'proguard-rules.pro'
 

Sample proguard-rules.pro which you can use to obfuscate code:

// Basic proguard rules
-optimizations !code/simplification/arithmetic
-keepattributes <em>Annotation</em>
-keepattributes InnerClasses
-keepattributes EnclosingMethod
-keep class *<em>.R$</em>

-dontskipnonpubliclibraryclasses
-forceprocessing
-optimizationpasses 5
-overloadaggressively

// Removing logging code
-assumenosideeffects class android.util.Log { public static *** d();
public static *** v(); public static *** i(); public static *** w(); public static *** e();
}

// Crashlytics code as given below which one can exclude

-keep class com.crashlytics.** { *; }
-keep class com.crashlytics.android.**
-keepattributes SourceFile,LineNumberTable



▪	M9: Reverse Engineering
▪	Bytecode Obfuscation
▪	Android Developer Resource to shrink and obfuscate your code in proguard
