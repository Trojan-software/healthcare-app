To implement a hooking detection solution, the following code (in Java or Kotlin) can be used to enumerate packages and figure out malicious tools. This should be used in conjunction with the native (C/C++) code to make detection more stronger and efficient.
Java:

function checkSuspiciousMethodsinStackTrace() { try {
Set libraries = new HashSet();
String mapsFilename = "/proc/" + android.os.Process.myPid() + "/maps"; BufferedReader reader = new BufferedReader(new FileReader(mapsFilename)); String line;
while((line = reader.readLine()) != null) {
if (line.endsWith(".so") || line.endsWith(".jar")) { int n = line.lastIndexOf(" "); libraries.add(line.substring(n + 1));
}
 
}
for (String library : libraries) { if(library.contains("com.saurik.substrate")) {
Log.wtf("HookDetection", "Substrate shared object found: " + library);
}
if(library.contains("XposedBridge.jar")) { Log.wtf("HookDetection", "Xposed JAR found: " + library);
}
}
reader.close();
}
catch (Exception e) { Log.wtf("HookDetection", e.toString());
}
}
function checkSuspiciousPackagesInstalled() {
PackageManager packageManager = context.getPackageManager(); List applicationInfoList =
packageManager.getInstalledApplications(PackageManager.GET_META_DATA); for(ApplicationInfo applicationInfo : applicationInfoList) {
if(applicationInfo.packageName.equals("de.robv.android.xposed.installer")) { Log.wtf("HookDetection", "Xposed found on the system.");
}
if(applicationInfo.packageName.equals("com.saurik.substrate")) { Log.wtf("HookDetection", "Substrate found on the system.");
}
}
}

Kotlin:

import android.content.pm.ApplicationInfo import android.content.pm.PackageManager import android.util.Log
import java.io.BufferedReader import java.io.FileReader import java.util.HashSet
fun checkSuspiciousMethodsInStackTrace() { try {
val libraries = mutableSetOf<String>()
val mapsFilename = "/proc/${android.os.Process.myPid()}/maps" val reader = BufferedReader(FileReader(mapsFilename))
var line: String?
while (reader.readLine().also { line = it } != null) {
if (line!!.endsWith(".so") || line.endsWith(".jar")) { val n = line!!.lastIndexOf(" ") libraries.add(line!!.substring(n + 1))
}
}
for (library in libraries) {
if (library.contains("com.saurik.substrate")) { Log.wtf("HookDetection", "Substrate shared object found: $library")
}
if (library.contains("XposedBridge.jar")) { Log.wtf("HookDetection", "Xposed JAR found: $library")
 
}
}
reader.close()
} catch (e: Exception) { Log.wtf("HookDetection", e.toString())
}
}
fun checkSuspiciousPackagesInstalled(context: Context) {
val packageManager: PackageManager = context.packageManager val applicationInfoList: List<ApplicationInfo> =
packageManager.getInstalledApplications(PackageManager.GET_META_DATA) for (applicationInfo in applicationInfoList) {
if (applicationInfo.packageName == "de.robv.android.xposed.installer") { Log.wtf("HookDetection", "Xposed found on the system.")
}
if (applicationInfo.packageName == "com.saurik.substrate") { Log.wtf("HookDetection", "Substrate found on the system.")
}
}
}

Native (via Java Native Interface) in C/C++:

static char keyword[] = "LIBFRIDA"; num_found = 0;
int scan_executable_segments(char * map) { char buf[512];
unsigned long start, end;
sscanf(map, "%lx-%lx %s", &start, &end, buf); if (buf[2] == 'x') {
return (find_mem_string(start, end, (char*)keyword, 8) == 1);
} else {
return 0;
}
}
void scan() {
if ((fd = my_openat(AT_FDCWD, "/proc/self/maps", O_RDONLY, 0)) >= 0) { while ((read_one_line(fd, map, MAX_LINE)) > 0) {
if (scan_executable_segments(map) == 1) { num_found++;
}
}
if (num_found > 1) {
/* Frida Detected */
}
}
boolean is_frida_server_listening() { struct sockaddr_in sa; memset(&sa, 0, sizeof(sa)); sa.sin_family = AF_INET; sa.sin_port = htons(27042);
inet_aton("127.0.0.1", &(sa.sin_addr));
int sock = socket(AF_INET , SOCK_STREAM , 0);
if (connect(sock , (struct sockaddr*)&sa , sizeof sa) != -1) {
/* Frida server detected. Do somethingâ€¦ */
 
}
}
public boolean checkRunningProcesses() { boolean returnValue = false;
// Get currently running application processes List<RunningServiceInfo> list = manager.getRunningServices(300); if(list != null){
String tempName;
for(int i=0;i<list.size();++i){ tempName = list.get(i).process; if(tempName.contains("fridaserver")) {
returnValue = true;
}
}
}
return returnValue;
}
